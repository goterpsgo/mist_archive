{
  "name": "stdout-stream",
  "description": "Non-blocking stdout stream",
  "version": "1.4.0",
  "repository": {
    "type": "git",
    "url": "mafintosh/stdout-stream"
  },
  "devDependencies": {
    "tape": "~2.12.3"
  },
  "scripts": {
    "test": "tape test/index.js"
  },
  "dependencies": {
    "readable-stream": "^2.0.1"
  },
  "readme": "# stdout-stream\n\nNon-blocking stdout stream\n\n\tnpm install stdout-stream\n\n[![build status](http://img.shields.io/travis/mafintosh/level-filesystem.svg?style=flat)](http://travis-ci.org/mafintosh/stdout-stream)\n![dat](http://img.shields.io/badge/Development%20sponsored%20by-dat-green.svg?style=flat)\n\n\n## Rant\n\nTry saving this example as `example.js`\n\n``` js\nconsole.error('start');\nprocess.stdout.write(new Buffer(1024*1024));\nconsole.error('end');\n```\n\nAnd run the following program\n\n```\nnode example.js | sleep 1000\n```\n\nThe program will never print `end` since stdout in node currently is blocking - even when its being piped (!).\n\nstdout-stream tries to fix this by being a stream that writes to stdout but never blocks\n\n## Usage\n\n``` js\nvar stdout = require('stdout-stream');\n\nstdout.write('hello\\n'); // write should NEVER block\nstdout.write('non-blocking\\n')\nstdout.write('world\\n');\n```\n\n`stdout-stream` should behave in the same way as `process.stdout` (i.e. do not end on pipe etc)\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "stdout-stream@1.4.0",
  "_from": "stdout-stream@^1.4.0"
}
